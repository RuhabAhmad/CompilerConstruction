================================================================================
                    NEXUS LANGUAGE - FORMAL GRAMMAR
                    CS4031 - Compiler Construction
                          Assignment 01
================================================================================

This document provides the formal lexical grammar for the Nexus programming
language using Extended Backus-Naur Form (EBNF) notation and Regular Expressions.

================================================================================
1. LEXICAL GRAMMAR (TOKEN DEFINITIONS)
================================================================================

1.1 KEYWORDS
------------
KEYWORD ::= 'start' | 'finish' | 'loop' | 'condition' | 'declare' | 
            'output' | 'input' | 'function' | 'return' | 'break' | 
            'continue' | 'else'

Regular Expression:
    (start|finish|loop|condition|declare|output|input|function|return|break|continue|else)

Note: All keywords are case-sensitive and must be lowercase.


1.2 IDENTIFIERS
---------------
IDENTIFIER ::= UPPERCASE_LETTER (LOWERCASE_LETTER | DIGIT | '_')* 

Constraints:
    - Must start with uppercase letter (A-Z)
    - Followed by 0-30 lowercase letters, digits, or underscores
    - Maximum total length: 31 characters

Regular Expression:
    [A-Z][a-z0-9_]{0,30}

Examples:
    Valid:   Count, Variable_name, X, Total_sum_2024
    Invalid: count, Variable, 2Count, myVariable


1.3 INTEGER LITERALS
--------------------
INTEGER_LITERAL ::= SIGN? DIGIT+

SIGN ::= '+' | '-'
DIGIT ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'

Regular Expression:
    [+-]?[0-9]+

Examples:
    Valid:   42, +100, -567, 0
    Invalid: 12.34, 1,000


1.4 FLOATING-POINT LITERALS
---------------------------
FLOAT_LITERAL ::= SIGN? DIGIT+ '.' DIGIT{1,6} EXPONENT?

EXPONENT ::= ('e' | 'E') SIGN? DIGIT+

Regular Expression:
    [+-]?[0-9]+\.[0-9]{1,6}([eE][+-]?[0-9]+)?

Constraints:
    - Must have decimal point
    - Fractional part: 1 to 6 digits
    - Optional exponent with optional sign

Examples:
    Valid:   3.14, +2.5, -0.123456, 1.5e10, 2.0E-3
    Invalid: 3., .14, 1.2345678


1.5 STRING LITERALS
-------------------
STRING_LITERAL ::= '"' (STRING_CHAR | ESCAPE_SEQUENCE)* '"'

STRING_CHAR ::= Any character except '"', '\', or newline
ESCAPE_SEQUENCE ::= '\' ('"' | '\' | 'n' | 't' | 'r')

Regular Expression:
    "([^"\\\n]|\\["\\\ntr])*"

Valid Escape Sequences:
    \"  - Double quote
    \\  - Backslash
    \n  - Newline
    \t  - Tab
    \r  - Carriage return

Examples:
    "Hello, World!"
    "Path: C:\\Users\\Data"
    "She said \"Hello\""
    "Line 1\nLine 2"


1.6 CHARACTER LITERALS
----------------------
CHAR_LITERAL ::= ''' (CHAR_CHAR | CHAR_ESCAPE) '''

CHAR_CHAR ::= Any single character except ''', '\', or newline
CHAR_ESCAPE ::= '\' (''' | '\' | 'n' | 't' | 'r')

Regular Expression:
    '([^'\\\n]|\\['\\\ntr])'

Valid Escape Sequences:
    \'  - Single quote
    \\  - Backslash
    \n  - Newline
    \t  - Tab
    \r  - Carriage return

Examples:
    'A', '5', '\n', '\t', '\\'


1.7 BOOLEAN LITERALS
--------------------
BOOLEAN_LITERAL ::= 'true' | 'false'

Regular Expression:
    (true|false)

Note: Case-sensitive (must be lowercase)


1.8 OPERATORS
-------------

Arithmetic Operators:
    OP_EXPONENT   ::= '**'
    OP_MULTIPLY   ::= '*'
    OP_DIVIDE     ::= '/'
    OP_MODULO     ::= '%'
    OP_PLUS       ::= '+'
    OP_MINUS      ::= '-'

Regular Expression (Arithmetic):
    (\*\*|[+\-*/%])

Relational Operators:
    OP_EQUAL          ::= '=='
    OP_NOT_EQUAL      ::= '!='
    OP_LESS_EQUAL     ::= '<='
    OP_GREATER_EQUAL  ::= '>='
    OP_LESS           ::= '<'
    OP_GREATER        ::= '>'

Regular Expression (Relational):
    (==|!=|<=|>=|<|>)

Logical Operators:
    OP_AND  ::= '&&'
    OP_OR   ::= '||'
    OP_NOT  ::= '!'

Regular Expression (Logical):
    (&&|\|\||!)

Assignment Operators:
    OP_ASSIGN       ::= '='
    OP_PLUS_ASSIGN  ::= '+='
    OP_MINUS_ASSIGN ::= '-='
    OP_MULT_ASSIGN  ::= '*='
    OP_DIV_ASSIGN   ::= '/='

Regular Expression (Assignment):
    (\+=|-=|\*=|/=|=)

Increment/Decrement Operators:
    OP_INCREMENT ::= '++'
    OP_DECREMENT ::= '--'

Regular Expression (Inc/Dec):
    (\+\+|--)


1.9 PUNCTUATORS
---------------
PUNCTUATORS ::= '(' | ')' | '{' | '}' | '[' | ']' | ',' | ';' | ':'

Regular Expression:
    [(){}[\],;:]

Descriptions:
    (  - Left parenthesis
    )  - Right parenthesis
    {  - Left brace (block start)
    }  - Right brace (block end)
    [  - Left bracket (array subscript)
    ]  - Right bracket
    ,  - Comma (separator)
    ;  - Semicolon (statement terminator)
    :  - Colon


1.10 COMMENTS
-------------

Single-line Comment:
    COMMENT_SINGLE ::= '##' ANY_CHAR* NEWLINE

Regular Expression:
    ##[^\n]*

Multi-line Comment:
    COMMENT_MULTI ::= '#*' (NOT_STAR | '*'+ NOT_STAR_HASH)* '*'+ '#'
    
    where:
        NOT_STAR      ::= Any character except '*'
        NOT_STAR_HASH ::= Any character except '*' or '#'

Regular Expression:
    #\*([^*]|\*+[^*#])*\*+#

Note: Comments are removed during lexical analysis and do not produce tokens.


1.11 WHITESPACE
---------------
WHITESPACE ::= ' ' | '\t' | '\r' | '\n'

Regular Expression:
    [ \t\r\n]+

Note: Whitespace is skipped but line and column positions are tracked.


================================================================================
2. TOKEN RECOGNITION PRIORITY
================================================================================

To avoid ambiguity, patterns are checked in the following order:

1. Multi-line comments          (#*...*#)
2. Single-line comments         (##...)
3. Multi-character operators    (**, ==, !=, <=, >=, &&, ||, ++, --, +=, -=, *=, /=)
4. Keywords                     (start, finish, loop, etc.)
5. Boolean literals             (true, false)
6. Identifiers                  ([A-Z][a-z0-9_]{0,30})
7. Floating-point literals      (must precede integers)
8. Integer literals             ([+-]?[0-9]+)
9. String literals              ("...")
10. Character literals          ('.')
11. Single-character operators  (+, -, *, /, %, <, >, =, !)
12. Punctuators                 (, ), {, }, [, ], ,, ;, :)
13. Whitespace                  (skip)

This order ensures:
- Longest match principle
- Keywords are not mistaken for identifiers
- Multi-char operators are not split into single-char operators
- Floats are recognized before integers


================================================================================
3. OPERATOR PRECEDENCE AND ASSOCIATIVITY
================================================================================

Precedence (Highest to Lowest):
    Level 1:  **                (Exponentiation)         Right-to-left
    Level 2:  *, /, %           (Multiplicative)         Left-to-right
    Level 3:  +, -              (Additive)               Left-to-right
    Level 4:  <, <=, >, >=      (Relational)             Left-to-right
    Level 5:  ==, !=            (Equality)               Left-to-right
    Level 6:  &&                (Logical AND)            Left-to-right
    Level 7:  ||                (Logical OR)             Left-to-right
    Level 8:  =, +=, -=, *=, /= (Assignment)             Right-to-left

Special Operators:
    ++, --  (Increment/Decrement)  Can be prefix or postfix
    !       (Logical NOT)          Prefix unary operator


================================================================================
4. COMPLETE TOKEN SET
================================================================================

The Nexus language recognizes the following token types:

KEYWORDS (12):
    KEYWORD_START, KEYWORD_FINISH, KEYWORD_LOOP, KEYWORD_CONDITION,
    KEYWORD_DECLARE, KEYWORD_OUTPUT, KEYWORD_INPUT, KEYWORD_FUNCTION,
    KEYWORD_RETURN, KEYWORD_BREAK, KEYWORD_CONTINUE, KEYWORD_ELSE

LITERALS (5 categories):
    IDENTIFIER, INTEGER_LITERAL, FLOAT_LITERAL, STRING_LITERAL,
    CHAR_LITERAL, BOOLEAN_LITERAL

OPERATORS (30):
    Arithmetic: OP_PLUS, OP_MINUS, OP_MULTIPLY, OP_DIVIDE, OP_MODULO, OP_EXPONENT
    Relational: OP_EQUAL, OP_NOT_EQUAL, OP_LESS, OP_LESS_EQUAL, OP_GREATER, OP_GREATER_EQUAL
    Logical: OP_AND, OP_OR, OP_NOT
    Assignment: OP_ASSIGN, OP_PLUS_ASSIGN, OP_MINUS_ASSIGN, OP_MULT_ASSIGN, OP_DIV_ASSIGN
    Inc/Dec: OP_INCREMENT, OP_DECREMENT

PUNCTUATORS (9):
    PUNCT_LPAREN, PUNCT_RPAREN, PUNCT_LBRACE, PUNCT_RBRACE,
    PUNCT_LBRACKET, PUNCT_RBRACKET, PUNCT_COMMA, PUNCT_SEMICOLON, PUNCT_COLON

SPECIAL:
    COMMENT_SINGLE, COMMENT_MULTI, WHITESPACE, EOF, ERROR


================================================================================
5. LEXICAL CONVENTIONS
================================================================================

5.1 Case Sensitivity
- Keywords: Must be lowercase (case-sensitive)
- Boolean literals: Must be lowercase (case-sensitive)
- Identifiers: Must start with uppercase, followed by lowercase/digits/underscores
- All other tokens: Case-sensitive where applicable

5.2 Maximum Lengths
- Identifiers: 31 characters maximum
- Float fractional part: 6 digits maximum
- Strings: No specified limit (memory dependent)

5.3 Invalid Characters
- Any character not part of a valid token is an error
- Examples: @, $, `, ~, ^, &amp; (except in &&), | (except in ||)

5.4 Line Terminators
- Recognized: \n, \r, \r\n
- Line numbers start at 1
- Column numbers start at 1

5.5 Comment Nesting
- Single-line comments cannot be nested (no effect)
- Multi-line comments do NOT support nesting in basic implementation
- Bonus implementation may support nested multi-line comments


================================================================================
6. ERROR CONDITIONS
================================================================================

The scanner detects the following lexical errors:

1. Invalid characters: Characters not part of any valid token
2. Malformed integers: Invalid number formats
3. Malformed floats: 
   - Missing fractional part
   - Too many decimal digits (>6)
   - Invalid exponent format
4. Invalid identifiers:
   - Starting with lowercase or digit or underscore
   - Exceeding 31 character limit
   - Contains uppercase after first character
5. Unterminated strings: String not closed before newline or EOF
6. Unterminated character literals: Character literal not properly closed
7. Invalid escape sequences: Unknown escape sequences in strings/characters
8. Unclosed multi-line comments: Comment started but never closed

All errors include:
- Error type
- Line and column position
- Lexeme that caused the error
- Descriptive error message


================================================================================
7. REGULAR EXPRESSION SUMMARY
================================================================================

Complete set of regular expressions for all token types:

Keywords:       (start|finish|loop|condition|declare|output|input|function|return|break|continue|else)
Booleans:       (true|false)
Identifiers:    [A-Z][a-z0-9_]{0,30}
Integers:       [+-]?[0-9]+
Floats:         [+-]?[0-9]+\.[0-9]{1,6}([eE][+-]?[0-9]+)?
Strings:        "([^"\\\n]|\\["\\\ntr])*"
Characters:     '([^'\\\n]|\\['\\\ntr])'
Arithmetic:     (\*\*|[+\-*/%])
Relational:     (==|!=|<=|>=|<|>)
Logical:        (&&|\|\||!)
Assignment:     (\+=|-=|\*=|/=|=)
Inc/Dec:        (\+\+|--)
Punctuators:    [(){}[\],;:]
Comment-Single: ##[^\n]*
Comment-Multi:  #\*([^*]|\*+[^*#])*\*+#
Whitespace:     [ \t\r\n]+


================================================================================
END OF GRAMMAR SPECIFICATION
================================================================================